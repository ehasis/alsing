namespace HelloWorld
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.syntaxBoxControl1 = new Alsing.Windows.Forms.SyntaxBoxControl();
            this.syntaxDocument1 = new Alsing.SourceCode.SyntaxDocument(this.components);
            this.SuspendLayout();
            // 
            // syntaxBoxControl1
            // 
            this.syntaxBoxControl1.ActiveView = Alsing.Windows.Forms.ActiveView.BottomRight;
            this.syntaxBoxControl1.AutoListPosition = null;
            this.syntaxBoxControl1.AutoListSelectedText = "a123";
            this.syntaxBoxControl1.AutoListVisible = false;
            this.syntaxBoxControl1.BackColor = System.Drawing.Color.White;
            this.syntaxBoxControl1.BorderStyle = Alsing.Windows.Forms.BorderStyle.None;
            this.syntaxBoxControl1.CopyAsRTF = false;
            this.syntaxBoxControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.syntaxBoxControl1.Document = this.syntaxDocument1;
            this.syntaxBoxControl1.FontName = "Courier new";
            this.syntaxBoxControl1.FontSize = 12F;
            this.syntaxBoxControl1.ImeMode = System.Windows.Forms.ImeMode.NoControl;
            this.syntaxBoxControl1.InfoTipCount = 1;
            this.syntaxBoxControl1.InfoTipPosition = null;
            this.syntaxBoxControl1.InfoTipSelectedIndex = 1;
            this.syntaxBoxControl1.InfoTipVisible = false;
            this.syntaxBoxControl1.Location = new System.Drawing.Point(0, 0);
            this.syntaxBoxControl1.LockCursorUpdate = false;
            this.syntaxBoxControl1.Name = "syntaxBoxControl1";
            this.syntaxBoxControl1.ShowScopeIndicator = false;
            this.syntaxBoxControl1.Size = new System.Drawing.Size(844, 592);
            this.syntaxBoxControl1.SmoothScroll = false;
            this.syntaxBoxControl1.SplitviewH = -4;
            this.syntaxBoxControl1.SplitviewV = -4;
            this.syntaxBoxControl1.TabGuideColor = System.Drawing.Color.FromArgb(((int)(((byte)(244)))), ((int)(((byte)(243)))), ((int)(((byte)(234)))));
            this.syntaxBoxControl1.TabIndex = 0;
            this.syntaxBoxControl1.Text = "syntaxBoxControl1";
            this.syntaxBoxControl1.WhitespaceColor = System.Drawing.SystemColors.ControlDark;
            // 
            // syntaxDocument1
            // 
            this.syntaxDocument1.Lines = new string[] {
        "// *\r",
        "// * Copyright (C) 2008 Roger Alsing : http://www.RogerAlsing.com\r",
        "// *\r",
        "// * This library is free software; you can redistribute it and/or modify it\r",
        "// * under the terms of the GNU Lesser General Public License 2.1 or later, as\r",
        "// * published by the Free Software Foundation. See the included license.txt\r",
        "// * or http://www.gnu.org/copyleft/lesser.html for details.\r",
        "// *\r",
        "// *\r",
        "//no parsing , just splitting and making whitespace possible\r",
        "//1 sec to finnish ca 10000 rows\r",
        "\r",
        "namespace Alsing.SourceCode.SyntaxDocumentParsers\r",
        "{\r",
        "    /// <summary>\r",
        "    /// \r",
        "    /// </summary>\r",
        "    public sealed class DefaultParser : IParser\r",
        "    {\r",
        "        private SyntaxDefinition mSyntaxDefinition;\r",
        "        private long Version;\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        public DefaultParser()\r",
        "        {\r",
        "            mSyntaxDefinition = null;\r",
        "        }\r",
        "\r",
        "        #region IParser Members\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        public SyntaxDefinition SyntaxDefinition\r",
        "        {\r",
        "            get { return mSyntaxDefinition; }\r",
        "            set\r",
        "            {\r",
        "                mSyntaxDefinition = value;\r",
        "\r",
        "                if (mSyntaxDefinition == null)\r",
        "                {\r",
        "                    var l = new SyntaxDefinition();\r",
        "                    l.mainSpanDefinition = new SpanDefinition(l) {MultiLine = tru" +
            "e};\r",
        "                    mSyntaxDefinition = l;\r",
        "                }\r",
        "\r",
        "                Version = long.MinValue;\r",
        "                mSyntaxDefinition.Version = long.MinValue + 1;\r",
        "                Document.ReParse();\r",
        "            }\r",
        "        }\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        /// <param name=\"index\"></param>\r",
        "        /// <param name=\"ParseKeywords\"></param>\r",
        "        public void ParseRow(int index, bool ParseKeywords)\r",
        "        {\r",
        "            InternalParseLine(index, ParseKeywords);\r",
        "            if (SyntaxDefinition != null)\r",
        "            {\r",
        "                if (Version != SyntaxDefinition.Version)\r",
        "                {\r",
        "                    SyntaxDefinition.UpdateLists();\r",
        "                    Version = SyntaxDefinition.Version;\r",
        "                }\r",
        "            }\r",
        "\r",
        "\r",
        "            Document.InvokeRowParsed(Document[index]);\r",
        "        }\r",
        "\r",
        "        #endregion\r",
        "\r",
        "        #region PUBLIC PROPERTY SEPARATORS\r",
        "\r",
        "        public string Separators\r",
        "        {\r",
        "            get { return SyntaxDefinition.Separators; }\r",
        "            set { SyntaxDefinition.Separators = value; }\r",
        "        }\r",
        "\r",
        "        #endregion\r",
        "\r",
        "        #region Optimerat och klart\r",
        "\r",
        "        // ska anropas om \"is same but different\" är true\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        public SyntaxDocument Document { get; set; }\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        /// <param name=\"SyntaxFile\"></param>\r",
        "        public void Init(string SyntaxFile)\r",
        "        {\r",
        "            try\r",
        "            {\r",
        "                if (!SyntaxFile.ToLowerInvariant().EndsWith(\".syn\")\r",
        "                    )\r",
        "                    SyntaxFile += \".syn\";\r",
        "\r",
        "\r",
        "                SyntaxDefinition = new SyntaxDefinitionLoader().Load(SyntaxFile);" +
            "\r",
        "            }\r",
        "            catch {}\r",
        "        }\r",
        "\r",
        "        public void Init(string syntaxFile, string separators)\r",
        "        {\r",
        "            try\r",
        "            {\r",
        "                if (!syntaxFile.ToLowerInvariant().EndsWith(\".syn\")\r",
        "                    )\r",
        "                    syntaxFile += \".syn\";\r",
        "\r",
        "\r",
        "                SyntaxDefinition = new SyntaxDefinitionLoader().Load(syntaxFile, " +
            "separators);\r",
        "            }\r",
        "            catch {}\r",
        "        }\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        /// <param name=\"syntaxDefinition\"></param>\r",
        "        public void Init(SyntaxDefinition syntaxDefinition)\r",
        "        {\r",
        "            SyntaxDefinition = syntaxDefinition;\r",
        "        }\r",
        "\r",
        "        /// <summary>\r",
        "        /// \r",
        "        /// </summary>\r",
        "        /// <param name=\"RowIndex\"></param>\r",
        "        public void ParsePreviewLine(int RowIndex)\r",
        "        {\r",
        "            Row Row = Document[RowIndex];\r",
        "            Row.Clear();\r",
        "            Row.Add(Row.Text);\r",
        "            Row.RowState = RowState.NotParsed;\r",
        "        }\r",
        "\r",
        "        private void MakeSame(int RowIndex)\r",
        "        {\r",
        "            Row row = Document[RowIndex];\r",
        "\r",
        "            //copy back the old segments to this line...\r",
        "            Span seg = row.endSpan;\r",
        "            Span seg2 = Document[RowIndex + 1].startSpan;\r",
        "            while (seg != null)\r",
        "            {\r",
        "                foreach (Word w in row)\r",
        "                {\r",
        "                    if (w.Span == seg)\r",
        "                    {\r",
        "                        if (w.Span.StartWord == w)\r",
        "                            seg2.StartWord = w;\r",
        "\r",
        "                        if (w.Span.EndWord == w)\r",
        "                            seg2.EndWord = w;\r",
        "\r",
        "                        w.Span = seg2;\r",
        "                    }\r",
        "                }\r",
        "\r",
        "                if (seg == row.startSpan)\r",
        "                    row.startSpan = seg2;\r",
        "\r",
        "                if (seg == row.endSpan)\r",
        "                    row.endSpan = seg2;\r",
        "\r",
        "\r",
        "                if (row.startSpans.IndexOf(seg) >= 0)\r",
        "                    row.startSpans[row.startSpans.IndexOf(seg)] = seg2;\r",
        "\r",
        "                if (row.endSpans.IndexOf(seg) >= 0)\r",
        "                    row.endSpans[row.endSpans.IndexOf(seg)] = seg2;\r",
        "\r",
        "                seg = seg.Parent;\r",
        "                seg2 = seg2.Parent;\r",
        "            }\r",
        "            row.SetExpansionSegment();\r",
        "        }\r",
        "\r",
        "        //om denna är true\r",
        "        // så ska INTE nästa rad parse\'as , utan denna ska fixas så den blir som " +
            "den förra... (kopiera span)\r",
        "        private bool IsSameButDifferent(int RowIndex, Span oldStartSpan)\r",
        "        {\r",
        "            //is this the last row ? , if so , bailout\r",
        "            if (RowIndex >= Document.Count - 1)\r",
        "                return false;\r",
        "\r",
        "            Row row = Document[RowIndex];\r",
        "            Span seg = row.endSpan;\r",
        "            Span oldEndSpan = Document[RowIndex + 1].startSpan;\r",
        "            Span oseg = oldEndSpan;\r",
        "\r",
        "            bool diff = false;\r",
        "\r",
        "            while (seg != null)\r",
        "            {\r",
        "                if (oseg == null)\r",
        "                {\r",
        "                    diff = true;\r",
        "                    break;\r",
        "                }\r",
        "\r",
        "                //Id1+=seg.spanDefinition.GetHashCode ().ToString (System.Globali" +
            "zation.CultureInfo.InvariantCulture);\r",
        "                if (seg.spanDefinition != oseg.spanDefinition)\r",
        "                {\r",
        "                    diff = true;\r",
        "                    break;\r",
        "                }\r",
        "\r",
        "                if (seg.Parent != oseg.Parent)\r",
        "                {\r",
        "                    diff = true;\r",
        "                    break;\r",
        "                }\r",
        "\r",
        "                seg = seg.Parent;\r",
        "                oseg = oseg.Parent;\r",
        "            }\r",
        "\r",
        "\r",
        "            if (diff || row.startSpan != oldStartSpan)\r",
        "                return false;\r",
        "\r",
        "            return true;\r",
        "        }\r",
        "\r",
        "        #endregion\r",
        "\r",
        "        private ScanResultWord GetNextWord(string Text, Span currentSpan, int\r",
        "                                                                                 " +
            "   StartPos, ref bool HasComplex)\r",
        "        {\r",
        "            SpanDefinition spanDefinition = currentSpan.spanDefinition;\r",
        "\r",
        "            #region ComplexFind\r",
        "\r",
        "            int BestComplexPos = - 1;\r",
        "            Pattern BestComplexPattern = null;\r",
        "            string BestComplexToken = \"\";\r",
        "            var complexword = new ScanResultWord();\r",
        "            if (HasComplex)\r",
        "            {\r",
        "                foreach (Pattern pattern in spanDefinition.ComplexPatterns)\r",
        "                {\r",
        "                    PatternScanResult scanres = pattern.IndexIn(Text, StartPos,\r",
        "                                                                pattern.Parent.Ca" +
            "seSensitive, Separators);\r",
        "                    if (scanres.Token != \"\")\r",
        "                    {\r",
        "                        if (scanres.Index < BestComplexPos || BestComplexPos == -" +
            " 1)\r",
        "                        {\r",
        "                            BestComplexPos = scanres.Index;\r",
        "                            BestComplexPattern = pattern;\r",
        "                            BestComplexToken = scanres.Token;\r",
        "                        }\r",
        "                    }\r",
        "                }\r",
        "\r",
        "\r",
        "                if (BestComplexPattern != null)\r",
        "                {\r",
        "                    complexword.HasContent = true;\r",
        "                    complexword.ParentList = BestComplexPattern.Parent;\r",
        "                    complexword.Pattern = BestComplexPattern;\r",
        "                    complexword.Position = BestComplexPos;\r",
        "                    complexword.Token = BestComplexToken;\r",
        "                }\r",
        "                else\r",
        "                {\r",
        "                    HasComplex = false;\r",
        "                }\r",
        "            }\r",
        "\r",
        "            #endregion\r",
        "\r",
        "            #region SimpleFind \r",
        "\r",
        "            var simpleword = new ScanResultWord();\r",
        "            for (int i = StartPos; i < Text.Length; i++)\r",
        "            {\r",
        "                //bailout if we found a complex pattern before this char pos\r",
        "                if (i > complexword.Position && complexword.HasContent)\r",
        "                    break;\r",
        "\r",
        "                #region 3+ char pattern\r",
        "\r",
        "                if (i <= Text.Length - 3)\r",
        "                {\r",
        "                    string key = Text.Substring(i, 3).ToLowerInvariant();\r",
        "                    var patterns2 = (PatternCollection)\r",
        "                                    spanDefinition.LookupTable[key];\r",
        "                    //ok , there are patterns that start with this char\r",
        "                    if (patterns2 != null)\r",
        "                    {\r",
        "                        foreach (Pattern pattern in patterns2)\r",
        "                        {\r",
        "                            int len = pattern.StringPattern.Length;\r",
        "                            if (i + len > Text.Length)\r",
        "                                continue;\r",
        "\r",
        "                            char lastpatternchar = char.ToLower(pattern.StringPat" +
            "tern[len -\r",
        "                                                                                 " +
            "     1]);\r",
        "                            char lasttextchar = char.ToLower(Text[i + len - 1]);\r" +
            "",
        "\r",
        "                            #region Case Insensitive\r",
        "\r",
        "                            if (lastpatternchar == lasttextchar)\r",
        "                            {\r",
        "                                if (!pattern.IsKeyword || (pattern.IsKeyword &&\r",
        "                                                           pattern.HasSeparators(" +
            "Text, i)))\r",
        "                                {\r",
        "                                    if (!pattern.Parent.CaseSensitive)\r",
        "                                    {\r",
        "                                        string s = Text.Substring(i, len).ToLower" +
            "Invariant();\r",
        "\r",
        "                                        if (s == pattern.StringPattern.ToLowerInv" +
            "ariant())\r",
        "                                        {\r",
        "                                            simpleword.HasContent = true;\r",
        "                                            simpleword.ParentList = pattern.Paren" +
            "t;\r",
        "                                            simpleword.Pattern = pattern;\r",
        "                                            simpleword.Position = i;\r",
        "                                            simpleword.Token = pattern.Parent.Nor" +
            "malizeCase ? pattern.StringPattern : Text.Substring(i, len);\r",
        "                                            break;\r",
        "                                        }\r",
        "                                    }\r",
        "                                    else\r",
        "                                    {\r",
        "                                        string s = Text.Substring(i, len);\r",
        "\r",
        "                                        if (s == pattern.StringPattern)\r",
        "                                        {\r",
        "                                            simpleword.HasContent = true;\r",
        "                                            simpleword.ParentList = pattern.Paren" +
            "t;\r",
        "                                            simpleword.Pattern = pattern;\r",
        "                                            simpleword.Position = i;\r",
        "                                            simpleword.Token = pattern.StringPatt" +
            "ern;\r",
        "                                            break;\r",
        "                                        }\r",
        "                                    }\r",
        "                                }\r",
        "                            }\r",
        "                        }\r",
        "\r",
        "                        #endregion\r",
        "                    }\r",
        "                }\r",
        "\r",
        "                #endregion\r",
        "\r",
        "                if (simpleword.HasContent)\r",
        "                    break;\r",
        "\r",
        "                #region single char pattern\r",
        "\r",
        "                char c = Text[i];\r",
        "                var patterns = (PatternCollection) spanDefinition.LookupTable[c];" +
            "\r",
        "                if (patterns != null)\r",
        "                {\r",
        "                    //ok , there are patterns that start with this char\r",
        "                    foreach (Pattern pattern in patterns)\r",
        "                    {\r",
        "                        int len = pattern.StringPattern.Length;\r",
        "                        if (i + len > Text.Length)\r",
        "                            continue;\r",
        "\r",
        "                        char lastpatternchar = pattern.StringPattern[len - 1];\r",
        "                        char lasttextchar = Text[i + len - 1];\r",
        "\r",
        "                        if (!pattern.Parent.CaseSensitive)\r",
        "                        {\r",
        "                            #region Case Insensitive\r",
        "\r",
        "                            if (char.ToLower(lastpatternchar) == char.ToLower(las" +
            "ttextchar))\r",
        "                            {\r",
        "                                if (!pattern.IsKeyword || (pattern.IsKeyword &&\r",
        "                                                           pattern.HasSeparators(" +
            "Text, i)))\r",
        "                                {\r",
        "                                    string s = Text.Substring(i, len).ToLowerInva" +
            "riant();\r",
        "\r",
        "                                    if (s == pattern.StringPattern.ToLowerInvaria" +
            "nt())\r",
        "                                    {\r",
        "                                        simpleword.HasContent = true;\r",
        "                                        simpleword.ParentList = pattern.Parent;\r",
        "                                        simpleword.Pattern = pattern;\r",
        "                                        simpleword.Position = i;\r",
        "                                        simpleword.Token = pattern.Parent.Normali" +
            "zeCase ? pattern.StringPattern : Text.Substring(i, len);\r",
        "                                        break;\r",
        "                                    }\r",
        "                                }\r",
        "                            }\r",
        "\r",
        "                            #endregion\r",
        "                        }\r",
        "                        else\r",
        "                        {\r",
        "                            #region Case Sensitive\r",
        "\r",
        "                            if (lastpatternchar == lasttextchar)\r",
        "                            {\r",
        "                                if (!pattern.IsKeyword || (pattern.IsKeyword &&\r",
        "                                                           pattern.HasSeparators(" +
            "Text, i)))\r",
        "                                {\r",
        "                                    string s = Text.Substring(i, len);\r",
        "\r",
        "                                    if (s == pattern.StringPattern)\r",
        "                                    {\r",
        "                                        simpleword.HasContent = true;\r",
        "                                        simpleword.ParentList = pattern.Parent;\r",
        "                                        simpleword.Pattern = pattern;\r",
        "                                        simpleword.Position = i;\r",
        "                                        simpleword.Token = pattern.StringPattern;" +
            "\r",
        "                                        break;\r",
        "                                    }\r",
        "                                }\r",
        "                            }\r",
        "\r",
        "                            #endregion\r",
        "                        }\r",
        "                    }\r",
        "\r",
        "                    if (simpleword.HasContent)\r",
        "                        break;\r",
        "                }\r",
        "\r",
        "                #endregion\r",
        "            }\r",
        "\r",
        "            #endregion\r",
        "\r",
        "            if (complexword.HasContent && simpleword.HasContent)\r",
        "            {\r",
        "                if (simpleword.Position == complexword.Position)\r",
        "                {\r",
        "                    if (simpleword.Token.Length >= complexword.Token.Length)\r",
        "                        return simpleword;\r",
        "                    return complexword;\r",
        "                }\r",
        "\r",
        "                if (simpleword.Position < complexword.Position)\r",
        "                    return simpleword;\r",
        "\r",
        "                if (simpleword.Position > complexword.Position)\r",
        "                    return complexword;\r",
        "            }\r",
        "\r",
        "            if (simpleword.HasContent)\r",
        "                return simpleword;\r",
        "\r",
        "            if (complexword.HasContent)\r",
        "                return complexword;\r",
        "\r",
        "\r",
        "            return new ScanResultWord();\r",
        "        }\r",
        "\r",
        "\r",
        "        private void ParseText(Row Row, Span currentSpan, string Text)\r",
        "        {\r",
        "            int CurrentPosition = 0;\r",
        "            bool HasComplex = true;\r",
        "            while (true)\r",
        "            {\r",
        "                ScanResultWord Word = GetNextWord(Text, currentSpan, CurrentPosit" +
            "ion,\r",
        "                                                  ref HasComplex);\r",
        "\r",
        "                if (!Word.HasContent)\r",
        "                {\r",
        "                    ParseTools.AddString(Text.Substring(CurrentPosition), Row,\r",
        "                                         currentSpan.spanDefinition.Style, curren" +
            "tSpan);\r",
        "                    break;\r",
        "                }\r",
        "                ParseTools.AddString(Text.Substring(CurrentPosition, Word.Positio" +
            "n -\r",
        "                                                                     CurrentPosit" +
            "ion), Row,\r",
        "                                     currentSpan.spanDefinition.Style, currentSpa" +
            "n);\r",
        "                ParseTools.AddPatternString(Word.Token, Row, Word.Pattern,\r",
        "                                            Word.ParentList.Style, currentSpan,\r",
        "                                            false);\r",
        "                CurrentPosition = Word.Position + Word.Token.Length;\r",
        "            }\r",
        "        }\r",
        "\r",
        "        private void InternalParseLine(int index, bool ParseKeywords)\r",
        "        {\r",
        "            if (mSyntaxDefinition == null)\r",
        "                return;\r",
        "\r",
        "            //\r",
        "            //\t\t\tif (ParseKeywords)\r",
        "            //\t\t\t\treturn;\r",
        "            //\t\t\tParseKeywords=true;\r",
        "            SyntaxDocument doc = Document;\r",
        "            Row Row = doc[index];\r",
        "            Span oldEndSpan = Row.endSpan;\r",
        "            Span oldStartSpan = Row.startSpan;\r",
        "            bool Fold = !Row.IsCollapsed;\r",
        "\r",
        "\r",
        "            if (Row.IsCollapsedEndPart)\r",
        "            {\r",
        "                //Row.expansion_EndSpan.Expanded = true;\r",
        "                //Row.expansion_EndSpan.EndRow = null;\r",
        "                Row.expansion_EndSpan.EndWord = null;\r",
        "            }\r",
        "\r",
        "\r",
        "            //set startsegment for this row\r",
        "            if (index > 0)\r",
        "            {\r",
        "                Row.startSpan = Document[index - 1].endSpan;\r",
        "            }\r",
        "            else\r",
        "            {\r",
        "                if (Row.startSpan == null)\r",
        "                {\r",
        "                    Row.startSpan = new Span(Row) {spanDefinition = mSyntaxDefini" +
            "tion.mainSpanDefinition};\r",
        "                }\r",
        "            }\r",
        "\r",
        "            int CurrentPosition = 0;\r",
        "            Span currentSpan = Row.startSpan;\r",
        "\r",
        "\r",
        "            //kör tills vi kommit till slutet av raden..\r",
        "            Row.endSpans.Clear();\r",
        "            Row.startSpans.Clear();\r",
        "            Row.Clear();\r",
        "            //\t\tbool HasEndSegment=false;\r",
        "\r",
        "            while (true)\r",
        "            {\r",
        "                ScanResultSegment ChildSegment = GetNextChildSegment(Row,\r",
        "                                                                     currentSpan," +
            " CurrentPosition);\r",
        "                ScanResultSegment EndSegment = GetEndSegment(Row, currentSpan,\r",
        "                                                             CurrentPosition);\r",
        "\r",
        "                if ((EndSegment.HasContent && ChildSegment.HasContent &&\r",
        "                     EndSegment.Position <= ChildSegment.Position) ||\r",
        "                    (EndSegment.HasContent && ChildSegment.HasContent == false))\r" +
            "",
        "                {\r",
        "                    //this is an end span\r",
        "\r",
        "                    if (ParseKeywords)\r",
        "                    {\r",
        "                        string Text = Row.Text.Substring(CurrentPosition,\r",
        "                                                         EndSegment.Position - Cu" +
            "rrentPosition);\r",
        "                        ParseText(Row, currentSpan, Text);\r",
        "                    }\r",
        "\r",
        "                    Span oldseg = currentSpan;\r",
        "                    while (currentSpan != EndSegment.span)\r",
        "                    {\r",
        "                        Row.endSpans.Add(currentSpan);\r",
        "                        currentSpan = currentSpan.Parent;\r",
        "                    }\r",
        "                    Row.endSpans.Add(currentSpan);\r",
        "\r",
        "                    TextStyle st2 = currentSpan.Scope.Style;\r",
        "\r",
        "                    ParseTools.AddPatternString(EndSegment.Token, Row, EndSegment" +
            ".Pattern,\r",
        "                                                st2, currentSpan, false);\r",
        "                    while (oldseg != EndSegment.span)\r",
        "                    {\r",
        "                        oldseg.EndRow = Row;\r",
        "                        oldseg.EndWord = Row[Row.Count - 1];\r",
        "                        oldseg = oldseg.Parent;\r",
        "                    }\r",
        "\r",
        "                    currentSpan.EndRow = Row;\r",
        "                    currentSpan.EndWord = Row[Row.Count - 1];\r",
        "\r",
        "\r",
        "                    if (currentSpan.Parent != null)\r",
        "                        currentSpan = currentSpan.Parent;\r",
        "\r",
        "                    CurrentPosition = EndSegment.Position + EndSegment.Token.Leng" +
            "th;\r",
        "                }\r",
        "                else if (ChildSegment.HasContent)\r",
        "                {\r",
        "                    //this is a child block\r",
        "\r",
        "                    if (ParseKeywords)\r",
        "                    {\r",
        "                        string Text = Row.Text.Substring(CurrentPosition,\r",
        "                                                         ChildSegment.Position - " +
            "CurrentPosition);\r",
        "                        //TextStyle st=currentSpan.spanDefinition.Style;\r",
        "                        ParseText(Row, currentSpan, Text);\r",
        "                        //ParseTools.AddString (Text,Row,st,currentSpan);\r",
        "                    }\r",
        "\r",
        "\r",
        "                    var NewSeg = new Span\r",
        "                                 {\r",
        "                                     Parent = currentSpan,\r",
        "                                     spanDefinition = ChildSegment.spanDefinition" +
            ",\r",
        "                                     Scope = ChildSegment.Scope\r",
        "                                 };\r",
        "\r",
        "                    Row.startSpans.Add(NewSeg);\r",
        "\r",
        "                    TextStyle st2 = NewSeg.Scope.Style;\r",
        "                    ParseTools.AddPatternString(ChildSegment.Token, Row,\r",
        "                                                ChildSegment.Pattern, st2, NewSeg" +
            ", false);\r",
        "                    NewSeg.StartRow = Row;\r",
        "                    NewSeg.StartWord = Row[Row.Count - 1];\r",
        "\r",
        "\r",
        "                    currentSpan = NewSeg;\r",
        "                    CurrentPosition = ChildSegment.Position + ChildSegment.Token." +
            "Length;\r",
        "\r",
        "                    if (ChildSegment.Scope.spawnSpanOnStart != null)\r",
        "                    {\r",
        "                        var SpawnSeg = new Span\r",
        "                                       {\r",
        "                                           Parent = NewSeg,\r",
        "                                           spanDefinition = ChildSegment.Scope.sp" +
            "awnSpanOnStart,\r",
        "                                           Scope = new Scope(),\r",
        "                                           StartWord = NewSeg.StartWord\r",
        "                                       };\r",
        "                        Row.startSpans.Add(SpawnSeg);\r",
        "                        currentSpan = SpawnSeg;\r",
        "                    }\r",
        "                }\r",
        "                else\r",
        "                {\r",
        "                    if (CurrentPosition < Row.Text.Length)\r",
        "                    {\r",
        "                        if (ParseKeywords)\r",
        "                        {\r",
        "                            //we did not find a childblock nor an endblock , just" +
            " output the last pice of text\r",
        "                            string Text = Row.Text.Substring(CurrentPosition);\r",
        "                            //TextStyle st=currentSpan.spanDefinition.Style;\t\r",
        "                            ParseText(Row, currentSpan, Text);\r",
        "                            //ParseTools.AddString (Text,Row,st,currentSpan);\r",
        "                        }\r",
        "                    }\r",
        "                    break;\r",
        "                }\r",
        "            }\r",
        "\r",
        "            while (!currentSpan.spanDefinition.MultiLine)\r",
        "            {\r",
        "                Row.endSpans.Add(currentSpan);\r",
        "                currentSpan = currentSpan.Parent;\r",
        "            }\r",
        "\r",
        "            Row.endSpan = currentSpan;\r",
        "            Row.SetExpansionSegment();\r",
        "\r",
        "            Row.RowState = ParseKeywords ? RowState.AllParsed : RowState.SpanPars" +
            "ed;\r",
        "\r",
        "            if (IsSameButDifferent(index, oldStartSpan))\r",
        "            {\r",
        "                MakeSame(index);\r",
        "                //if (!IsSameButDifferent(index))\r",
        "                //\tSystem.Diagnostics.Debugger.Break();\r",
        "            }\r",
        "\r",
        "            if (Row.CanFold)\r",
        "                Row.expansion_StartSpan.Expanded = Fold;\r",
        "\r",
        "            //dont flag next line as needs parsing if only parsing keywords\r",
        "            if (!ParseKeywords)\r",
        "            {\r",
        "                if (oldEndSpan != null)\r",
        "                {\r",
        "                    if (Row.endSpan != oldEndSpan && index <= Document.Count - 2)" +
            "\r",
        "                    {\r",
        "                        //if (Row.CanFold)\r",
        "                        //\tRow.expansion_StartSpan.Expanded = true;\r",
        "                        Document[index + 1].AddToParseQueue();\r",
        "                        Document.NeedResetRows = true;\r",
        "                    }\r",
        "                }\r",
        "                else if (index <= Document.Count - 2)\r",
        "                {\r",
        "                    //if (Row.CanFold)\r",
        "                    //\tRow.expansion_StartSpan.Expanded = true;\r",
        "                    Document[index + 1].AddToParseQueue();\r",
        "                    Document.NeedResetRows = true;\r",
        "                }\r",
        "            }\r",
        "\r",
        "            if (oldEndSpan != null)\r",
        "            {\r",
        "                //expand span if this line dont have an end word\r",
        "                if (oldEndSpan.EndWord == null)\r",
        "                    oldEndSpan.Expanded = true;\r",
        "            }\r",
        "        }\r",
        "\r",
        "\r",
        "        private ScanResultSegment GetEndSegment(Row Row, Span currentSpan,\r",
        "                                                int StartPos)\r",
        "        {\r",
        "            //this row has no text , just bail out...\r",
        "            if (StartPos >= Row.Text.Length || currentSpan.Scope == null)\r",
        "                return new ScanResultSegment();\r",
        "\r",
        "            var Result = new ScanResultSegment {HasContent = false, IsEndSegment " +
            "= false};\r",
        "\r",
        "\r",
        "            //-------------------------------------------------------------------" +
            "-------------\r",
        "            //scan for childblocks\r",
        "            //scan each scope in each childblock\r",
        "\r",
        "            Span seg = currentSpan;\r",
        "\r",
        "            while (seg != null)\r",
        "            {\r",
        "                if (seg == currentSpan || seg.spanDefinition.TerminateChildren)\r",
        "                {\r",
        "                    foreach (Pattern end in seg.Scope.EndPatterns)\r",
        "                    {\r",
        "                        PatternScanResult psr = end.IndexIn(Row.Text, StartPos,\r",
        "                                                            seg.Scope.CaseSensiti" +
            "ve, Separators);\r",
        "                        int CurrentPosition = psr.Index;\r",
        "                        if (psr.Token != \"\")\r",
        "                        {\r",
        "                            if ((psr.Index < Result.Position && Result.HasContent" +
            ") ||\r",
        "                                !Result.HasContent)\r",
        "                            {\r",
        "                                //we found a better match\r",
        "                                //store this new match\r",
        "                                Result.Pattern = end;\r",
        "                                Result.Position = CurrentPosition;\r",
        "                                Result.Token = psr.Token;\r",
        "                                Result.HasContent = true;\r",
        "                                Result.span = seg;\r",
        "                                Result.Scope = null;\r",
        "\r",
        "\r",
        "                                if (!end.IsComplex)\r",
        "                                {\r",
        "                                    if (seg.Scope.NormalizeCase)\r",
        "                                        if (!seg.Scope.Start.IsComplex)\r",
        "                                            Result.Token = end.StringPattern;\r",
        "                                }\r",
        "                            }\r",
        "                        }\r",
        "                    }\r",
        "                }\r",
        "                seg = seg.Parent;\r",
        "            }\r",
        "\r",
        "            //no result , return new ScanResultSegment();\r",
        "            if (!Result.HasContent)\r",
        "                return new ScanResultSegment();\r",
        "\r",
        "            return Result;\r",
        "        }\r",
        "\r",
        "        private ScanResultSegment GetNextChildSegment(Row Row, Span\r",
        "                                                                   currentSpan, i" +
            "nt StartPos)\r",
        "        {\r",
        "            //this row has no text , just bail out...\r",
        "            if (StartPos >= Row.Text.Length)\r",
        "                return new ScanResultSegment();\r",
        "\r",
        "\r",
        "            var Result = new ScanResultSegment {HasContent = false, IsEndSegment " +
            "= false};\r",
        "\r",
        "\r",
        "            foreach (SpanDefinition ChildBlock in currentSpan.spanDefinition.chil" +
            "dSpanDefinitions)\r",
        "            {\r",
        "                //scan each scope in each childblock\r",
        "                foreach (Scope Scope in ChildBlock.ScopePatterns)\r",
        "                {\r",
        "                    PatternScanResult psr = Scope.Start.IndexIn(Row.Text, StartPo" +
            "s,\r",
        "                                                                Scope.CaseSensiti" +
            "ve, Separators);\r",
        "                    int CurrentPosition = psr.Index;\r",
        "                    if ((!Result.HasContent || CurrentPosition < Result.Position)" +
            " &&\r",
        "                        psr.Token != \"\")\r",
        "                    {\r",
        "                        //we found a better match\r",
        "                        //store this new match\r",
        "                        Result.Pattern = Scope.Start;\r",
        "                        Result.Position = CurrentPosition;\r",
        "                        Result.Token = psr.Token;\r",
        "                        Result.HasContent = true;\r",
        "                        Result.spanDefinition = ChildBlock;\r",
        "                        Result.Scope = Scope;\r",
        "\r",
        "                        if (Scope.NormalizeCase)\r",
        "                            if (!Scope.Start.IsComplex)\r",
        "                                Result.Token = Scope.Start.StringPattern;\r",
        "                    }\r",
        "                }\r",
        "            }\r",
        "\r",
        "\r",
        "            //no result ,  new ScanResultSegment();\r",
        "            if (!Result.HasContent)\r",
        "                return new ScanResultSegment();\r",
        "\r",
        "            return Result;\r",
        "        }\r",
        "    }\r",
        "}"};
            this.syntaxDocument1.MaxUndoBufferSize = 1000;
            this.syntaxDocument1.Modified = false;
            this.syntaxDocument1.SyntaxFile = "C:\\Puzzle\\SyntaxBox\\Puzzle.Syntaxbox.DefaultSyntaxFiles\\CSharp.syn";
            this.syntaxDocument1.UndoStep = 0;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(844, 592);
            this.Controls.Add(this.syntaxBoxControl1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.ResumeLayout(false);

        }

        #endregion

        private Alsing.Windows.Forms.SyntaxBoxControl syntaxBoxControl1;
        private Alsing.SourceCode.SyntaxDocument syntaxDocument1;
    }
}

